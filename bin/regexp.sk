type symb
type lett
type word

val equal : (symb, lett) → ()

val eps : word
val isempty : word → ()
val head : word → lett
val tail : word → word
val cons : (lett, word) → word
val wrdcmp : (word, word) → ()

val cut_dot (w: word) : (word, word) =
  branch
    (eps, w)
  or
    let l = head w in
    let t = tail w in
    let (t1, t2) = cut_dot t in
    let t1' = cons (l, t1) in
    (t1', t2)
  end

val cut_star (w: word) : (word, word) =
  let l = head w in
  let t = tail w in
  let (t1, t2) = cut_dot t in
  let t1' = cons (l, t1) in
  (t1', t2)


type nat
val isz : nat → ()
val pred : nat → nat

type expr =
  | Empty
  | Eps
  | Symb symb
  | Or (expr, expr)
  | Dot (expr, expr)
  | Star expr
  | StarLight expr
  | Plus expr
  | Exp (expr, nat)
  | ExpLight (expr, nat)
  | Option expr
  | Group expr
  | Ref cref


type tr_elt =
  | TrEps
  | TrSymb symb
  | TrOrL
  | TrOrR
  | TrParL
  | TrParR
  | TrStarL
  | TrStarR
  | TrGroupL cref
  | TrGroupR
  | TrRef (cref, word)

type trace =
  | Nil
  | Elt tr_elt
  | Conc (trace, trace)

type cref
type heap

val empty_heap : heap
val alloc : heap → (cref, heap)
val set : (cref, word, heap) → heap
val get : (cref, heap) → word

val newref () : m<cref> =
  λ (h: heap) →
  let (nr, h') = alloc h in
  (nr, Elt (TrGroupL nr), h')

val setref ((r: cref), (e: expr), (w: word)): result =
  λ (h: heap) →
  let h' = set (r, w, h) in
  ((e, w), Elt (TrGroupR), h')

val getref ((r: cref), (e: expr)) : result =
  λ (h: heap) →
  let wcap = get (r, h) in
  ((e, wcap), Nil, h)

type m<a> = heap → (a, trace, heap)
type result = m<(expr, word)>

val return<a> (v: a) : m<a> = λ (h:heap) → (v, Nil, h)
val ret ((e: expr), (w: word)): result = return<(expr, word)> (e, w)

val bind<a, b> ((x: m<a>), (f: a → m<b>)) : m<b> =
  λ (h: heap) →
  let (va, tra, ha) = x h in
  let xb = f va in
  let (vb, trb, hb) = xb ha in
  (vb, Conc(tra, trb), hb)

val log (te:tr_elt) : m<()> =
  λ (h: heap) → ((), Elt te, h)

binder @ = bind

val eval ((e: expr), (w: word)) : result =
  branch
    let Eps = e in
    eval (Star(Empty), w);@
    ret (e, w)
  or
    let Symb s = e in
    let l = head w in
    let t = tail w in
    isempty t;
    equal (s, l);
    log (TrSymb s);@
    ret (e, w)
  or
    let Or (e1, e2) = e in
    log TrOrL;@
    let (e1', _) =@ eval (e1, w) in
    log TrParR;@
    ret (Or (e1', e2), w)
  or
    let Or (e1, e2) = e in
    log TrOrR;@
    let (e2', _) =@ eval (e2, w) in
    log TrParR;@
    ret (Or (e1, e2'), w)
  or
    let Dot (e1, e2) = e in
    let (w1, w2) = cut_dot w in
    log TrParL;@
    let (e1', _) =@ eval (e1, w1) in
    let (e2', _) =@ eval (e2, w2) in
    log TrParR;@
    ret (Dot (e1', e2'), w)
  or
    let Star _ = e in
    isempty w;
    log TrEps;@
    ret (e, w)
  or
    let Star e1 = e in
    let (w1, w2) = cut_star w in
    log TrParL;@
    log TrStarL;@
    let (e1', _) =@ eval (e1, w1) in
    log TrStarR;@
    let (e1'', _) =@ eval (StarLight e1', w2) in
    log TrParR;@
    ret (e1'', w)
  or
    let StarLight e1 = e in
    isempty w;
    ret (Star e1, w)
  or
    let StarLight e1 = e in
    let (w1, w2) = cut_star w in
    log TrStarL;@
    let (e1', _) =@ eval (e1, w1) in
    log TrStarR;@
    let (e1'', _) =@ eval (StarLight e1', w2) in
    ret (e1'', w)
  or
    let Plus e1 = e in
    let (w1, w2) = cut_star w in
    log TrParL;@
    log TrStarL;@
    let (e1', _) =@ eval (e1, w1) in
    log TrStarR;@
    let (e1'', _) =@ eval (StarLight e1', w2) in
    log TrParR;@
    ret (e1'', w)
  or
    let Exp (_, n) = e in
    isz n;
    eval (Eps, w);@
    ret (e, w)
  or
    let Exp (e1, n) = e in
    let (w1, w2) = cut_dot w in
    log TrParL;@
    log TrStarL;@
    let (e1', _) =@ eval (e1, w1) in
    log TrStarR;@
    let pn = pred n in
    let (e1'', _) =@ eval (ExpLight (e1', pn), w2) in
    log TrParR;@
    ret (e1'', w)
  or
    let ExpLight (e1, n) = e in
    isz n;
    eval (StarLight(Empty), w);@
    ret (Exp (e1, n), w)
  or
    let ExpLight (e1, n) = e in
    let (w1, w2) = cut_dot w in
    log TrStarL;@
    let (e1', _) =@ eval (e1, w1) in
    log TrStarR;@
    let pn = pred n in
    let (e1'', _) =@ eval (ExpLight (e1', pn), w2) in
    ret (e1'', w)
  or
    let Option _ = e in
    eval (Eps, w);@
    ret (e, w)
  or
    let Option e1 = e in
    let (e1', _) =@ eval (e1, w) in
    ret (Option e1', w)
  or
    let Group e1 = e in
    let nr =@ newref () in
    eval (e1, w);@
    setref (nr, e1, w)
  or 
    let Ref r = e in
    let (_, wcap) =@ getref (r, e) in
    wrdcmp (w, wcap);
    log (TrRef (r, wcap));@
    ret (e, w)
  end


val exec ((e: expr), (w: word)) : (trace, heap) =
  let x = eval (e, w) in
  let (_, tr, h) = x empty_heap in
  (tr, h)