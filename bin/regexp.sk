type symb
type lett
type word

val lett_of_symb : symb → lett
val equal : (symb, lett) → ()

val eps : word
val isempty : word → ()
val head : word → lett
val tail : word → word
val cons : (lett, word) → word

val cut_dot (w: word) : (word, word) =
  branch
    (eps, w)
  or
    let l = head w in
    let t = tail w in
    let (t1, t2) = cut_dot t in
    let t1' = cons (l, t1) in
    (t1', t2)
  end

val cut_star (w: word) : (word, word) =
  let l = head w in
  let t = tail w in
  let (t1, t2) = cut_dot t in
  let t1' = cons (l, t1) in
  (t1', t2)


type expr =
  | Empty
  | Eps
  | Symb symb
  | Or (expr, expr)
  | Dot (expr, expr)
  | Star expr
  | Group expr


type tr_elt =
  | TrEps
  | TrSymb symb
  | TrOrL
  | TrOrR
  | TrOrEnd
  | TrDotL
  | TrDotR
  | TrStarL
  | TrStarR

type trace =
  | Nil
  | Elt tr_elt
  | Conc (trace, trace)

type loc
type heap

val empty_heap : heap
val alloc : heap → (loc, heap)
val set : (loc, word, heap) → heap
val get : (loc, heap) → word

type m<a> = heap → (a, trace, heap)
type result = m<word>

val return<a> (v: a) : m<a> = λ (h:heap) → (v, Nil, h)
val ret (v: word): result = return<word> v

val bind<a, b> ((w: m<a>), (f: a → m<b>)) : m<b> =
  λ (h: heap) →
  let (va, tra, ha) = w h in
  let wb = f va in
  let (vb, trb, hb) = wb ha in
  (vb, Conc(tra, trb), hb)

val log (e:tr_elt) : m<()> =
  λ (h: heap) → ((), Elt e, h)

binder @ = bind

val eval ((e: expr), (w: word)) : result =
  branch
    let Eps = e in
    eval (Star(Empty), w);@
    log (TrEps);@
    ret w
  or
    let Symb s = e in
    let l = head w in
    let t = tail w in
    isempty t;
    equal (s, l);
    log (TrSymb s);@
    ret w
  or
    let Or (e1, _) = e in
    log (TrOrL);@
    eval (e1, w);@
    log (TrOrEnd);@
    ret w
  or
    let Or (_, e2) = e in
    log (TrOrR);@
    eval (e2, w);@
    log (TrOrEnd);@
    ret w
  or
    let Dot (e1, e2) = e in
    let (w1, w2) = cut_dot w in
    log (TrDotL);@
    eval (e1, w1);@
    log (TrDotR);@
    log (TrDotL);@
    eval (e2, w2);@
    log (TrDotR);@
    ret w
  or
    let Star _ = e in
    isempty w;
    ret w
  or
    let Star e1 = e in
    let (w1, w2) = cut_star w in
    log (TrStarL);@
    eval (e1, w1);@
    log (TrStarR);@
    eval (e, w2);@
    ret w
  or
    let Group e1 = e in
    λ (h: heap) →
    let (l, h') = alloc h in
    let x = eval (e1, w) in
    let (w2, tr, h'') = x h' in
    let h''' = set (l, w2, h'') in
    (w2, tr, h''')
  end


val exec ((e: expr), (w: word)) : (word, trace, heap) =
  let w = eval (e, w) in
  w empty_heap