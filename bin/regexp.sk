type symb
type lett
type word

val lett_of_symb : symb → lett
val equal : (symb, lett) → ()

val eps : word
val isempty : word → ()
val head : word → lett
val tail : word → word
val cons : (lett, word) → word


val cut_dot (w: word) : (word, word) =
  branch
    (eps, w)
  or
    let l = head w in
    let t = tail w in
    let (t1, t2) = cut_dot t in
    let t1' = cons (l, t1) in
    (t1', t2)
  end

val cut_star (w: word) : (word, word) =
  let l = head w in
  let t = tail w in
  let (t1, t2) = cut_dot t in
  let t1' = cons (l, t1) in
  (t1', t2)


type expr =
  | Empty
  | Eps
  | Symb symb
  | Or (expr, expr)
  | Dot (expr, expr)
  | Star expr


type tr_elt =
  | TrEps
  | TrSymb symb
  | TrOrL
  | TrOrR
  | TrOrEnd
  | TrDotL
  | TrDotR
  | TrStarL
  | TrStarR

type trace =
  | Nil
  | Elt tr_elt
  | Conc (trace, trace)


type m<a> = (a, trace)

val return<a> (v: a) : m<a> = (v, Nil)
val ret (v: ()): m<()> = return<()> v

val bind<a, b> ((w: m<a>), (f: a → m<b>)) : m<b> =
  let (v, tr) = w in
  let (v', tr') = f v in
  (v', Conc(tr, tr'))

val log (e:tr_elt) : m<()> =
  ((), Elt e)

type result = m<()>

binder @ = bind

val eval ((e: expr), (w: word)) : result =
  branch
    let Eps = e in
    eval (Star(Empty), w);@
    log (TrEps)
  or
    let Symb s = e in
    let l = head w in
    let t = tail w in
    isempty t;
    equal (s, l);
    log (TrSymb s)
  or
    let Or (e1, _) = e in
    log (TrOrL);@
    eval (e1, w);@
    log (TrOrEnd)
  or
    let Or (_, e2) = e in
    log (TrOrR);@
    eval (e2, w);@
    log (TrOrEnd)
  or
    let Dot (e1, e2) = e in
    let (w1, w2) = cut_dot w in
    log (TrDotL);@
    eval (e1, w1);@
    log (TrDotR);@
    log (TrDotL);@
    eval (e2, w2);@
    log (TrDotR)
  or
    let Star _ = e in
    isempty w;
    ret ()
  or
    let Star e1 = e in
    let (w1, w2) = cut_star w in
    log (TrStarL);@
    eval (e1, w1);@
    log (TrStarR);@
    eval (e, w2)
  end