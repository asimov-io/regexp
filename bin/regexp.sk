type symb
type lett
type word

val lett_of_symb : symb → lett
val equal : (symb, lett) → ()

val eps : word
val isempty : word → ()
val head : word → lett
val tail : word → word
val cons : (lett, word) → word

val cut_dot (w: word) : (word, word) =
  branch
    (eps, w)
  or
    let l = head w in
    let t = tail w in
    let (t1, t2) = cut_dot t in
    let t1' = cons (l, t1) in
    (t1', t2)
  end

val cut_star (w: word) : (word, word) =
  let l = head w in
  let t = tail w in
  let (t1, t2) = cut_dot t in
  let t1' = cons (l, t1) in
  (t1', t2)


type expr =
  | Empty
  | Eps
  | Symb symb
  | Or (expr, expr)
  | Dot (expr, expr)
  | Star expr
  | StarLight expr
  | Group expr
  | Ref cap


type tr_elt =
  | TrEps
  | TrSymb symb
  | TrOrL
  | TrOrR
  | TrOrEnd
  | TrParL
  | TrParR
  | TrStarL
  | TrStarR
  | TrGroupL cap
  | TrGroupR
  | TrRef (cap, word)

type trace =
  | Nil
  | Elt tr_elt
  | Conc (trace, trace)

type cap
type heap

val empty_heap : heap
val alloc : heap → (cap, heap)
val set : (cap, word, heap) → heap
val get : (cap, heap) → word
val wrdcmp : (word, word) → ()

val newcap () : m<cap> =
  λ (h: heap) →
  let (nc, h') = alloc h in
  (nc, Elt (TrGroupL nc), h')

val setcap ((c: cap), (w: word)): result =
  λ (h: heap) →
  let h' = set (c, w, h) in
  (w, Elt (TrGroupR), h')

val getcap (c: cap) : result =
  λ (h: heap) →
  let wcap = get (c, h) in
  (wcap, Nil, h)

type m<a> = heap → (a, trace, heap)
type result = m<word>

val return<a> (v: a) : m<a> = λ (h:heap) → (v, Nil, h)
val ret (w: word): result = return<word> w

val bind<a, b> ((x: m<a>), (f: a → m<b>)) : m<b> =
  λ (h: heap) →
  let (va, tra, ha) = x h in
  let xb = f va in
  let (vb, trb, hb) = xb ha in
  (vb, Conc(tra, trb), hb)

val log (te:tr_elt) : m<()> =
  λ (h: heap) → ((), Elt te, h)

binder @ = bind

val eval ((e: expr), (w: word)) : result =
  branch
    let Eps = e in
    eval (Star(Empty), w);@
    log TrEps;@
    ret w
  or
    let Symb s = e in
    let l = head w in
    let t = tail w in
    isempty t;
    equal (s, l);
    log (TrSymb s);@
    ret w
  or
    let Or (e1, _) = e in
    log TrOrL;@
    eval (e1, w);@
    log TrParR;@
    ret w
  or
    let Or (_, e2) = e in
    log TrOrR;@
    eval (e2, w);@
    log TrParR;@
    ret w
  or
    let Dot (e1, e2) = e in
    let (w1, w2) = cut_dot w in
    log TrParL;@
    eval (e1, w1);@
    eval (e2, w2);@
    log TrParR;@
    ret w
  or
    let Star _ = e in
    isempty w;
    ret w
  or
    let Star e1 = e in
    let (w1, w2) = cut_star w in
    log TrParL;@
    log TrStarL;@
    eval (e1, w1);@
    log TrStarR;@
    eval (StarLight e1, w2);@
    log TrParR;@
    ret w
  or
    let StarLight _ = e in
    isempty w;
    ret w
  or
    let StarLight e1 = e in
    let (w1, w2) = cut_star w in
    log TrStarL;@
    eval (e1, w1);@
    log TrStarR;@
    eval (e, w2);@
    ret w
  or
    let Group e1 = e in
    let nc =@ newcap () in
    eval (e1, w);@
    setcap (nc, w)
  or 
    let Ref c = e in
    let wcap =@ getcap c in
    wrdcmp (w, wcap);
    log (TrRef (c, wcap));@
    ret w
  end


val exec ((e: expr), (w: word)) : (trace, heap) =
  let x = eval (e, w) in
  let (_, tr, h) = x empty_heap in
  (tr, h)